import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import {
  type IsAddressEqualErrorType,
  isAddressEqual,
} from '../address/isAddressEqual.js'
import { type GetAddressErrorType, getAddress } from '../address/getAddress.js'
import {
  type RecoverMessageAddressErrorType,
  recoverMessageAddress,
} from '../signature/recoverMessageAddress.js'
import type { Message } from './types.js'
import { parseMessage } from './parseMessage.js'

export type VerifyMessageParameters = {
  /** The message to be verified. */
  message: string
  /** The signature that was generated by signing the message with the address's private key. */
  signature: Hex
}

export type VerifyMessageReturnType = boolean

export type VerifyMessageErrorType =
  | IsAddressEqualErrorType
  | GetAddressErrorType
  | RecoverMessageAddressErrorType
  | ErrorType

/**
 * @description Verifies EIP-4361 formated message.
 *
 * @example
 * const isValid = verifyMessage({
 *   message: {
 *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *     chainId: 1,
 *     domain: 'example.com',
 *     nonce: 'foobarbaz',
 *     uri: 'https://example.com/path',
 *     version: '1',
 *   },
 *   signature: '0x...',
 * })
 *
 * @see https://eips.ethereum.org/EIPS/eip-4361
 */
export async function verifyMessage(
  parameters: VerifyMessageParameters,
): Promise<VerifyMessageReturnType> {
  const { message, signature } = parameters

  const parsed = parseMessage(message)
  const { address } = parsed
  // TODO: Check
  // - scheme
  // - domain
  // - nonce
  // - expirationTime
  // - notBefore
  return isAddressEqual(
    getAddress(address),
    await recoverMessageAddress({ message, signature }),
  )
}
